import {
  computed,
  getCurrentInstance,
  inject,
  isReactive,
  isRef,
  markRaw,
  onUnmounted,
  provide,
  reactive,
  ref,
  warn,
  watch
} from "./chunk-XTNGYTB3.js";

// node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}

// node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP = "devtools-plugin:setup";

// node_modules/@vue/devtools-api/lib/esm/index.js
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const hook = getDevtoolsGlobalHook();
  if (hook) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const target = getTarget();
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor,
      setupFn
    });
  }
}

// node_modules/pinia/dist/pinia.esm-browser.js
var activePinia;
var setActivePinia = (pinia) => activePinia = pinia;
var getActivePinia = () => {
  if (!activePinia) {
    warn(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?

const pinia = createPinia()
app.use(pinia)

This will fail in production.`);
  }
  return activePinia;
};
var storesMap = new WeakMap();
var piniaSymbol = Symbol("pinia");
function isPlainObject(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var FileSaver_min = { exports: {} };
(function(module, exports) {
  (function(a, b) {
    b();
  })(commonjsGlobal, function() {
    function b(a2, b2) {
      return typeof b2 == "undefined" ? b2 = { autoBom: false } : typeof b2 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
    }
    function c(a2, b2, c2) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c2);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c2) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || (typeof window != "object" || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
      var i = f.URL || f.webkitURL, j = document.createElement("a");
      g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", typeof b2 == "string" ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
        i.revokeObjectURL(j.href);
      }, 4e4), setTimeout(function() {
        e(j);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
      if (g2 = g2 || f2.name || "download", typeof f2 != "string")
        navigator.msSaveOrOpenBlob(b(f2, h), g2);
      else if (d(f2))
        c(f2, g2, h);
      else {
        var i = document.createElement("a");
        i.href = f2, i.target = "_blank", setTimeout(function() {
          e(i);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), typeof b2 == "string")
        return c(b2, d2, e2);
      var h = b2.type === "application/octet-stream", i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j || h && i || a) && typeof FileReader != "undefined") {
        var k = new FileReader();
        k.onloadend = function() {
          var a2 = k.result;
          a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k.readAsDataURL(b2);
      } else {
        var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
  });
})(FileSaver_min);
function toastMessage(message, type) {
  const piniaMessage = "\u{1F34D} " + message;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
function isPinia(o) {
  return "_a" in o && "install" in o;
}
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
function checkNotFocusedError(error) {
  if (error.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
}
async function actionGlobalCopyState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
    toastMessage("Global state copied to clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
    console.error(error);
  }
}
async function actionGlobalPasteState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    pinia.state.value = JSON.parse(await navigator.clipboard.readText());
    toastMessage("Global state pasted from clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
    console.error(error);
  }
}
async function actionGlobalSaveState(pinia) {
  try {
    FileSaver_min.exports.saveAs(new Blob([JSON.stringify(pinia.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (error) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
var fileInput;
function getFileOpener() {
  if (!fileInput) {
    fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files)
          return resolve(null);
        const file = files.item(0);
        if (!file)
          return resolve(null);
        return resolve({ text: await file.text(), file });
      };
      fileInput.oncancel = () => resolve(null);
      fileInput.click();
    });
  }
  return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
  try {
    const open2 = await getFileOpener();
    const result = await open2();
    if (!result)
      return;
    const { text, file } = result;
    pinia.state.value = JSON.parse(text);
    toastMessage(`Global state imported from "${file.name}".`);
  } catch (error) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
var PINIA_ROOT_LABEL = "\u{1F34D} Pinia (root)";
var PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return "$id" in store ? {
    id: store.$id,
    label: store.$id
  } : {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  };
}
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const state2 = {
      state: Object.keys(store.state.value).map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      }))
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
function formatEventData(events) {
  if (!events)
    return {};
  if (Array.isArray(events)) {
    return events.reduce((data, event) => {
      data.keys.push(event.key);
      data.operations.push(event.type);
      data.oldValue[event.key] = event.oldValue;
      data.newValue[event.key] = event.newValue;
      return data;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay(events.type),
      key: formatDisplay(events.key),
      oldValue: events.oldValue,
      newValue: events.newValue
    };
  }
}
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
var registeredStores = new Map();
var isAlreadyInstalled;
var isTimelineActive = true;
var componentStateTypes = [];
var MUTATIONS_LAYER_ID = "pinia:mutations";
var INSPECTOR_ID = "pinia";
function addDevtools(app, store) {
  let hasSubscribed = true;
  const storeType = "\u{1F34D} " + store.$id;
  if (!registeredStores.has(store.$id)) {
    registeredStores.set(store.$id, store);
    componentStateTypes.push(storeType);
    hasSubscribed = false;
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.esm.dev/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.esm.dev",
    componentStateTypes,
    app
  }, (api) => {
    if (!isAlreadyInstalled) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia \u{1F34D}`,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia \u{1F34D}",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(store._p);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(store._p);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(store._p);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(store._p);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store2) => {
            payload.instanceData.state.push({
              type: storeType,
              key: "state",
              editable: true,
              value: store2.$state
            });
            if (store2._getters && store2._getters.length) {
              payload.instanceData.state.push({
                type: storeType,
                key: "getters",
                editable: false,
                value: store2._getters.reduce((getters, key) => {
                  getters[key] = store2[key];
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [store._p];
          stores = stores.concat(Array.from(registeredStores.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store2) => "$id" in store2 ? store2.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? store._p : registeredStores.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? store._p : registeredStores.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(store)) {
            if (path.length !== 1 || !store._customProperties.has(path[0]) || path[0] in store.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state", "value");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("\u{1F34D}")) {
          const storeId = payload.type.replace(/^🍍\s*/, "");
          const store2 = registeredStores.get(storeId);
          if (!store2) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store2, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      isAlreadyInstalled = true;
    } else {
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
    }
    if (hasSubscribed)
      return;
    store.$onAction(({ after, onError, name, args, store: store2 }) => {
      const groupId = runningActionId++;
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: "\u{1F6EB} " + name,
          subtitle: "start",
          data: {
            action: formatDisplay(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: "\u{1F6EC} " + name,
            subtitle: "end",
            data: {
              action: formatDisplay(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error) => {
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            logType: "error",
            title: "\u{1F4A5} " + name,
            subtitle: "end",
            data: {
              action: formatDisplay(name),
              args,
              error
            },
            groupId
          }
        });
      });
    });
    store.$subscribe(({ events, type }, state) => {
      if (!isTimelineActive)
        return;
      api.notifyComponentUpdate();
      api.sendInspectorState(INSPECTOR_ID);
      const eventData = {
        time: Date.now(),
        title: formatMutationType(type),
        data: formatEventData(events),
        groupId: activeAction
      };
      activeAction = void 0;
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "\u2935\uFE0F";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "\u{1F9E9}";
      } else if (events && !Array.isArray(events)) {
        eventData.subtitle = events.type;
      }
      if (events) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events
          }
        };
      }
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    });
    api.notifyComponentUpdate();
    toastMessage(`"${store.$id}" store installed`);
  });
}
var runningActionId = 0;
var activeAction;
function devtoolsPlugin({ app, store, options, pinia }) {
  const wrappedActions = {};
  const actions = Object.keys(options.actions || {}).reduce((storeActions, actionName) => {
    storeActions[actionName] = store[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    wrappedActions[actionName] = function() {
      setActivePinia(pinia);
      const _actionId = runningActionId;
      const trackedStore = new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      });
      return actions[actionName].apply(trackedStore, arguments);
    };
  }
  addDevtools(app, store);
  Object.assign(store, wrappedActions);
}
var IS_CLIENT = typeof window !== "undefined";
function createPinia() {
  const state = ref({});
  let localApp;
  let _p = [];
  const toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      pinia._a = localApp = app;
      app.provide(piniaSymbol, pinia);
      app.config.globalProperties.$pinia = pinia;
      if (IS_CLIENT) {
        setActivePinia(pinia);
      }
      toBeInstalled.forEach((plugin) => _p.push(plugin));
    },
    use(plugin) {
      if (!localApp) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    _a: localApp,
    state
  });
  if (IS_CLIENT) {
    pinia.use(devtoolsPlugin);
  }
  return pinia;
}
function innerPatch(target, patchToApply) {
  for (const key in patchToApply) {
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = innerPatch(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
var { assign } = Object;
function computedFromState(rootStateRef, id) {
  const reactiveObject = {};
  const state = rootStateRef.value[id];
  for (const key in state) {
    reactiveObject[key] = computed({
      get: () => rootStateRef.value[id][key],
      set: (value) => rootStateRef.value[id][key] = value
    });
  }
  return reactiveObject;
}
function initStore($id, buildState = () => ({}), initialState) {
  const pinia = getActivePinia();
  pinia.state.value[$id] = initialState || buildState();
  let isListening = true;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = false;
    {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      innerPatch(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    isListening = true;
    subscriptions.forEach((callback) => {
      callback(subscriptionMutation, pinia.state.value[$id]);
    });
  }
  function $subscribe(callback) {
    subscriptions.push(callback);
    const options = { deep: true, flush: "sync" };
    {
      options.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    const stopWatcher = watch(() => pinia.state.value[$id], (state, oldState) => {
      if (isListening) {
        callback({
          storeId: $id,
          type: MutationType.direct,
          events: debuggerEvents
        }, state);
      }
    }, options);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        stopWatcher();
      }
    };
    if (getCurrentInstance()) {
      onUnmounted(removeSubscription);
    }
    return removeSubscription;
  }
  function $onAction(callback) {
    actionSubscriptions.push(callback);
    const removeSubscription = () => {
      const idx = actionSubscriptions.indexOf(callback);
      if (idx > -1) {
        actionSubscriptions.splice(idx, 1);
      }
    };
    if (getCurrentInstance()) {
      onUnmounted(removeSubscription);
    }
    return removeSubscription;
  }
  function $reset() {
    pinia.state.value[$id] = buildState();
  }
  const storeWithState = {
    $id,
    _p: pinia,
    _as: actionSubscriptions,
    $patch,
    $subscribe,
    $onAction,
    $reset
  };
  const injectionSymbol = Symbol(`PiniaStore(${$id})`);
  return [
    storeWithState,
    {
      get: () => pinia.state.value[$id],
      set: (newState) => {
        isListening = false;
        pinia.state.value[$id] = newState;
        isListening = true;
      }
    },
    injectionSymbol
  ];
}
var noop = () => {
};
function buildStoreToUse(partialStore, descriptor, $id, getters = {}, actions = {}, options) {
  const pinia = getActivePinia();
  const computedGetters = {};
  for (const getterName in getters) {
    computedGetters[getterName] = computed(() => {
      setActivePinia(pinia);
      return getters[getterName].call(store, store);
    });
  }
  const wrappedActions = {};
  for (const actionName in actions) {
    wrappedActions[actionName] = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const localStore = this || store;
      let afterCallback = noop;
      let onErrorCallback = noop;
      function after(callback) {
        afterCallback = callback;
      }
      function onError(callback) {
        onErrorCallback = callback;
      }
      partialStore._as.forEach((callback) => {
        callback({ args, name: actionName, store: localStore, after, onError });
      });
      let ret;
      try {
        ret = actions[actionName].apply(localStore, args);
        Promise.resolve(ret).then(afterCallback).catch(onErrorCallback);
      } catch (error) {
        onErrorCallback(error);
        throw error;
      }
      return ret;
    };
  }
  const store = reactive(assign(IS_CLIENT ? {
    _customProperties: markRaw(new Set())
  } : {}, partialStore, computedFromState(pinia.state, $id), computedGetters, wrappedActions));
  Object.defineProperty(store, "$state", descriptor);
  if (IS_CLIENT) {
    store._getters = markRaw(Object.keys(getters));
  }
  pinia._p.forEach((extender) => {
    if (IS_CLIENT) {
      const extensions = extender({ store, app: pinia._a, pinia, options });
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign(store, extensions);
    } else {
      assign(store, extender({ store, app: pinia._a, pinia, options }));
    }
  });
  return store;
}
function defineStore(options) {
  const { id, state, getters, actions } = options;
  function useStore(pinia) {
    const currentInstance = getCurrentInstance();
    const shouldProvide = currentInstance && !pinia;
    pinia = pinia || currentInstance && inject(piniaSymbol);
    if (pinia)
      setActivePinia(pinia);
    pinia = getActivePinia();
    let stores = storesMap.get(pinia);
    if (!stores)
      storesMap.set(pinia, stores = new Map());
    let storeAndDescriptor = stores.get(id);
    let store;
    if (!storeAndDescriptor) {
      storeAndDescriptor = initStore(id, state, pinia.state.value[id]);
      stores.set(id, storeAndDescriptor);
      store = buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options);
      if (shouldProvide) {
        provide(storeAndDescriptor[2], store);
      }
    } else {
      store = currentInstance && inject(storeAndDescriptor[2], null) || buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options);
    }
    if (IS_CLIENT && currentInstance && currentInstance.proxy) {
      const vm = currentInstance.proxy;
      const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
      cache[store.$id] = store;
    }
    return store;
  }
  useStore.$id = id;
  return useStore;
}
function getCachedStore(vm, useStore) {
  const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
  const id = useStore.$id;
  return cache[id] || (cache[id] = useStore(vm.$pinia));
}
var mapStoreSuffix = "Store";
function setMapStoreSuffix(suffix) {
  mapStoreSuffix = suffix;
}
function mapStores(...stores) {
  if (Array.isArray(stores[0])) {
    console.warn(`[\u{1F34D}]: Directly pass all stores to "mapStores()" without putting them in an array:
Replace
	mapStores([useAuthStore, useCartStore])
with
	mapStores(useAuthStore, useCartStore)
This will fail in production if not fixed.`);
    stores = stores[0];
  }
  return stores.reduce((reduced, useStore) => {
    reduced[useStore.$id + mapStoreSuffix] = function() {
      return getCachedStore(this, useStore);
    };
    return reduced;
  }, {});
}
function mapState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function() {
      return getCachedStore(this, useStore)[key];
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function() {
      const store = getCachedStore(this, useStore);
      const storeKey = keysOrMapper[key];
      return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
    };
    return reduced;
  }, {});
}
var mapGetters = mapState;
function mapActions(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return getCachedStore(this, useStore)[key](...args);
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return getCachedStore(this, useStore)[keysOrMapper[key]](...args);
    };
    return reduced;
  }, {});
}
function mapWritableState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return getCachedStore(this, useStore)[key];
      },
      set(value) {
        return getCachedStore(this, useStore)[key] = value;
      }
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return getCachedStore(this, useStore)[keysOrMapper[key]];
      },
      set(value) {
        return getCachedStore(this, useStore)[keysOrMapper[key]] = value;
      }
    };
    return reduced;
  }, {});
}
export {
  MutationType,
  createPinia,
  defineStore,
  mapActions,
  mapGetters,
  mapState,
  mapStores,
  mapWritableState,
  setActivePinia,
  setMapStoreSuffix
};
/*!
  * pinia v2.0.0-beta.3
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
//# sourceMappingURL=pinia.js.map
