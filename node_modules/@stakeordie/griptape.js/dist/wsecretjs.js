import { SigningCosmWasmClient, CosmWasmClient } from 'secretjs';
const decoder = new TextDecoder(); // encoding defaults to utf-8
const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
const charactersLength = characters.length;
export function generateEntropyString(length) {
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
export function bech32(str, abbrv) {
    if (!str)
        return '';
    const half = (abbrv / 2) || 8;
    return str.substring(0, half) + '...' + str.substring(str.length - half, str.length);
}
function handleContractResponse(response) {
    try {
        return JSON.parse(decoder.decode(response.data));
    }
    catch (e) {
        throw e;
    }
}
const customFees = {
    upload: {
        amount: [{ amount: '2000000', denom: 'uscrt' }],
        gas: '2000000',
    },
    init: {
        amount: [{ amount: '500000', denom: 'uscrt' }],
        gas: '500000',
    },
    exec: {
        amount: [{ amount: '750000', denom: 'uscrt' }],
        gas: '750000',
    },
    send: {
        amount: [{ amount: '80000', denom: 'uscrt' }],
        gas: '80000',
    },
};
export class ScrtClient {
    cosmWasmClient;
    signingCosmWasmClient;
    constructor(cosmWasmClient, signingCosmWasmClient) {
        this.cosmWasmClient = cosmWasmClient;
        this.signingCosmWasmClient = signingCosmWasmClient;
    }
    async queryContract(address, queryMsg) {
        return await this.cosmWasmClient.queryContractSmart(address, queryMsg);
    }
    async executeContract(contractAddress, handleMsg, memo, transferAmount, fee) {
        try {
            const response = await this.signingCosmWasmClient.execute(contractAddress, handleMsg, memo, transferAmount, fee);
            return handleContractResponse(response);
        }
        catch (e) {
            // TODO improve error handling here
            throw e;
        }
    }
    async getAccount(address) {
        return await this.signingCosmWasmClient.getAccount(address);
    }
}
export function createScrtClient(restUrl, wallet) {
    return new Promise(async (resolve, reject) => {
        const cosmWasmClient = new CosmWasmClient(restUrl);
        const { keplr } = wallet;
        let chainId;
        try {
            chainId = await cosmWasmClient.getChainId();
        }
        catch (e) {
            resolve(undefined);
            return;
        }
        if (chainId) {
            try {
                // Enabling the wallet ASAP is recommended.
                await keplr.enable(chainId);
            }
            catch (e) {
                resolve(undefined);
                return;
            }
        }
        // Set the chain id in the wallet.
        wallet.chainId = chainId;
        const address = await wallet.getAddress();
        const signer = await window?.getOfflineSigner(chainId);
        const enigmaUtils = await wallet.keplr.getEnigmaUtils(chainId);
        const signingCosmWasmClient = new SigningCosmWasmClient(
        // @ts-ignore
        restUrl, address, signer, enigmaUtils, customFees);
        const scrtClient = new ScrtClient(cosmWasmClient, signingCosmWasmClient);
        resolve(scrtClient);
    });
}
